// Copyright 2019 The Nomulus Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package google.registry.monitoring.blackbox;

import static com.google.common.flogger.StackSize.SMALL;

import com.google.common.collect.ImmutableList;
import com.google.common.flogger.FluentLogger;
import google.registry.monitoring.blackbox.handlers.ActionHandler;
import google.registry.monitoring.blackbox.messages.OutboundMessageType;
import io.netty.util.AttributeKey;
import java.util.concurrent.TimeUnit;
import org.joda.time.Duration;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.util.HashedWheelTimer;
import io.netty.util.Timer;
import java.util.concurrent.Callable;
import javax.inject.Provider;

/**
 *Superclass that represents action generated by {@link ProbingStep}
 *
 * <p> Inherits from {@link Callable<ChannelFuture>}, as it has can be called
 * to perform its specified task, and return the {@link ChannelFuture} that will be informed when the
 * task has been completed </p>
 *
 * <p> Is an immutable class, as it is comprised of the tools necessary for making a specific type of connection.
 * It goes hand in hand with {@link Protocol}, which specifies the kind of overall connection to be made. {@link Protocol}
 * gives the outline and {@link ProbingAction} gives the details of that connection.</p>
 *
 * <p> There are two main subclasses. {@link NewChannelAction} creates a new channel based on the {@link Protocol} and
 * details specified for itself. {@link ExistingChannelAction} simply takes in an existing channel. Then both send
 * {@link OutboundMessageType} instance specified down the pipeline in the channel.</p>
 */


public abstract class ProbingAction implements Callable<ChannelFuture> {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  /** {@link AttributeKey} that specifies which {@link ProbingAction} is associated with the {@link Channel} in question*/
  public final static AttributeKey<ProbingAction> PROBING_ACTION_KEY = AttributeKey.valueOf("PROBING_ACTION_KEY");


  /**
   * The {@link ActionHandler} associated with this {@link ProbingAction}, which is always the
   * last {@link ChannelHandler} in the pipeline
   * */
  private ActionHandler actionHandler;


  /** Return of {@link ActionHandler}, which is always the last {@link ChannelHandler} in the pipeline */
  private ActionHandler actionHandler() {
    return actionHandler;
  }

  /** {@link Timer} that rate limits probing */
  private static final Timer timer = new HashedWheelTimer();


  /** Actual {@link Duration} of this delay */
  public abstract Duration delay();

  /** {@link OutboundMessageType} instance that we write and flush down pipeline to server */
  public abstract OutboundMessageType outboundMessage();

  /** {@link Channel} object that either created by or passed into this {@link ProbingAction} instance */
  public abstract Channel channel();

  /** The {@link Protocol} instance that specifies type of connection */
  public abstract Protocol protocol();

  public abstract String host();

  public abstract String path();

  public abstract <B extends Builder<B, P>, P extends ProbingAction> Builder<B, P> toBuilder();


  /** Performs the action specified by the ProbingAction and sets the ChannelPromise specified to a success */
  private void informListeners(ChannelPromise finished) {
    ChannelFuture channelFuture = actionHandler().getFuture();
    channel().writeAndFlush(outboundMessage());
    channelFuture.addListeners(
        future -> finished.setSuccess(),
        future -> {
          if (!protocol().persistentConnection()) {

            //If we created a new channel for this action, close the connection to the channel
            ChannelFuture closedFuture = channel().close();
            closedFuture.addListener(
                f -> {
                  if (f.isSuccess())
                    logger.atInfo().log("Closed stale channel. Moving on to next ProbingStep");
                  else
                    logger.atWarning()
                        .log("Could not close channel. Stale connection still exists.");
                }
            );
          }
        }
    );
  }
  /**
   * The method that sends the {@code outboundMessage} down the channel pipeline
   *
   * @return future that denotes when the action has been successfully performed
   */

  @Override
  public ChannelFuture call() {

    //Sets Action Handler to appropriately the last channel in the pipeline
    //Logs severe if the last channel in the pipeline is not
    try {
      this.actionHandler = (ActionHandler) this.channel().pipeline().last();
    } catch (ClassCastException exception) {
      logger.atSevere().withStackTrace(SMALL).log("Last Handler in the ChannelPipeline is not an ActionHandler");
    }

    //ChannelPromise that we use to inform ProbingStep when we are finished.
    ChannelPromise finished = channel().newPromise();

    //Every specified time frame by delay(), we perform the next action in our sequence and inform ProbingStep when finished
    if (!delay().equals(Duration.ZERO)) {
      timer.newTimeout(timeout -> {
            // Write appropriate message to pipeline
            informListeners(finished);
          },
          delay().getStandardSeconds(),
          TimeUnit.SECONDS);
    } else {
      //if no delay, just perform the next action, and inform ProbingStep when finished
      informListeners(finished);
    }

    return finished;
  }

  public abstract static class Builder<B extends Builder<B, P>, P extends ProbingAction> {

    public abstract B delay(Duration value);

    public abstract B outboundMessage(OutboundMessageType value);

    public abstract B protocol(Protocol value);

    public abstract B host(String value);

    public abstract B path(String value);

    public abstract P build();

  }

  /**
   * Adds provided {@link ChannelHandler}s to the {@link ChannelPipeline} specified
   *
   * @param channelPipeline is pipeline associated with channel that we want to add handlers to
   * @param handlerProviders are a list of provider objects that give us the requisite handlers Adds
   * to the pipeline, the list of handlers in the order specified
   */
  static void addHandlers(
      ChannelPipeline channelPipeline,
      ImmutableList<Provider<? extends ChannelHandler>> handlerProviders) {
    for (Provider<? extends ChannelHandler> handlerProvider : handlerProviders) {
      channelPipeline.addLast(handlerProvider.get());
    }
  }
}
